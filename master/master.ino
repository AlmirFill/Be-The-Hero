/*   Bibliotecas ultilizadas para controlar o display*/
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

/* iniciando configuração do display */
#define SCREEN_WIDTH 128 // OLED display largura, em pixels
#define SCREEN_HEIGHT 32 // OLED display altura, in pixels
#define SLAVE_ADDRESS 44

#define OLED_RESET     1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define btnFood D6
#define btnLye D5
#define btnSymptom D0
/*
    ADICIONAR AQUI A IMPORTAÇÃO DAS LIBS DO WEBSOKET
*/

#define TIMER_LONG 2000
#define TIMER_LITLE 500

long timerInit;

const unsigned char logo [] PROGMEM = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf8, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf8, 0x0f, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x0d, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x0d, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x0d, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x0d, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x0f, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x0f, 0xbf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x0f, 0xc2, 0x7f, 0x8c, 0xfc, 0x60, 0x08, 0xf0, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xdf, 0x8c, 0x7c, 0x60, 0x1c, 0x71, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0xdf, 0x8c, 0x3c, 0x67, 0xfc, 0x23, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf8, 0x03, 0x00, 0x9f, 0x8c, 0x1c, 0x67, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0x01, 0x81, 0x8f, 0x8c, 0x0c, 0x60, 0x1f, 0x07, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0x00, 0x83, 0x0f, 0x8c, 0x44, 0x60, 0x1f, 0x0f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x01, 0x86, 0x0f, 0x8c, 0x60, 0x60, 0x3f, 0x07, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x81, 0x38, 0x1f, 0x8c, 0x70, 0x67, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe7, 0xe0, 0x1f, 0x8c, 0x78, 0x67, 0xfc, 0x63, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x1f, 0x8c, 0x7c, 0x60, 0x08, 0x71, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0xf0, 0x00, 0x3f, 0x8c, 0x7e, 0x60, 0x08, 0xf8, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xcf, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x9f, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xbf, 0x80, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xbf, 0xc0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xbf, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

//Variavel de controle que referesse a inicialização do exame
bool exameOn = false;

String a;
String b;
int aux = 0;

enum {
    CMD_READ_PH1 = 1,
    CMD_READ_PH2  = 2,
    CMD_READ_HOUR = 3,
    CMD_CALIBRATE_PH7 = 4,
    CMD_CALIBRATE_PH1 = 5,
    CMD_FOOD = 6,
    CMD_LYE = 7,
    CMD_SYMPTOM = 8
    };

void setup(){
    displayInitialize();
    pinMode(btnFood, INPUT);
    pinMode(btnLye, INPUT);
    pinMode(btnSymptom, INPUT);
    Serial.begin(9600);
}

void loop(){
  handleBtnLye();
  handleBtnSymptom();
  handleBtnFood();
  showData();
  delay(100);
}

void sendCommand(const byte cmd, const int responseSize)
{
  Wire.beginTransmission (SLAVE_ADDRESS);
  Wire.write(cmd);
  Wire.endTransmission ();
  
  Wire.requestFrom(SLAVE_ADDRESS, responseSize);  
} 


void getPhValue(){

  String a, b, d, e;
  
  sendCommand (CMD_READ_PH1, 5);
  Serial.println("tudo ok ate aqui");
  
  for(int i = 0; i < 5; i++){
    Serial.println(i);
    Serial.print("Aux: ");
    Serial.println(aux);
    char c = Wire.read(); // receive a byte as character
      aux ++;
      if(aux <=2){
        a += c;
        Serial.println("aqi");
      }
      else if(aux > 2){
        b += c;
        if(aux > 4){
          aux = 0;
        }
      }
  }

    sendCommand (CMD_READ_PH2, 5);
 
  Serial.println("ok 2");
  
  for(int i = 0; i < 5; i++){
    Serial.println(i);
    Serial.print("Aux: ");
    Serial.println(aux);
    char c = Wire.read(); // receive a byte as character
      aux ++;
      if(aux <=2){
        d += c;
        Serial.println("aqi");
      }
      else if(aux > 2){
        e += c;
        if(aux > 4){
          aux = 0;
          Serial.println("Aq");
        }
      }
  }
  beforeInitExameDisplay(a, b, d, e);
  a, b, d, e = "";


  delay(200);
}

/* inicialização do display*/
void displayInitialize(){
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // limpando o buffer
  display.clearDisplay();
  Wire.begin();

  // Show the display buffer on the screen. You MUST call display() before
  // drawing commands to make them visible on screen!
  display.display();
  delay(2000);
}

// mostra se o exame esta iniciado
bool getExameOn(){
  bool stateReturn;
  
  stateReturn = exameOn;

  return stateReturn;
}

// Demostraçao de dados no display
void showData(){
    if(getExameOn()){
        getPhValue();
    }else{
        afterInitExameDisplay();
    }
    delay(100);
    
}

// dados antes do exame iniciar
void beforeInitExameDisplay(String ph1, String ph1Float, String ph2, String ph2Float){
    
    display.clearDisplay();

    display.setCursor(17,2);
    display.setTextSize(1);             // Draw 2X-scale text
    display.setTextColor(SSD1306_WHITE);
    display.println(F("CANAL 1  CANAL 2"));
    
    display.setTextSize(2); 
    // Display PH Data 
    display.setCursor(24,18);
    display.println(ph1);

    display.setTextSize(1);
    display.setCursor(46,18);
    display.println(ph1Float);

    display.setTextSize(2);
    display.setCursor(78, 18);
    display.println(ph2);  
                            // display PH1 value
    display.setTextSize(1);
    display.setCursor(98,18);
    display.println(ph2Float);

    display.display();
}

//dados depois do exame começar
void afterInitExameDisplay(){
    
    display.clearDisplay();

    // display.setCursor(20,12);
    // display.setTextSize(1);             // Draw 2X-scale text
    // display.setTextColor(SSD1306_WHITE);
    // display.println(F("INICIAR EXAME"));
    display.drawBitmap(0, 0, logo, 128, 35, WHITE);
    display.display();
    
}

void handleBtnLye(){
  if(digitalRead(btnLye) == HIGH)
  {
    timerInit = millis();

    while((millis() - timerInit < TIMER_LONG) && digitalRead(btnLye) == HIGH){delay(1);};

    if(millis() - timerInit >= TIMER_LONG  && getExameOn())
    {
      sendCommand(CMD_LYE, 1); 
      drawMessage(">> deitar <<");
    } 

    if(millis() - timerInit < TIMER_LITLE)
    {
      sendCommand(CMD_CALIBRATE_PH7, 1);

      drawMessage(">> CALIBRATE PH7 <<");
    }
  }
}

void handleBtnSymptom(){ 
  if(digitalRead(btnSymptom) == HIGH)
  {
    timerInit = millis();

    while((millis() - timerInit < TIMER_LONG) && digitalRead(btnSymptom) == HIGH){delay(1);};

    if(millis() - timerInit >= TIMER_LONG  && getExameOn())
    {
      sendCommand(CMD_SYMPTOM, 1);

      drawMessage(">> SINTOMA <<");
    } 

    if(millis() - timerInit < TIMER_LITLE)
    {
      exameOn = true;

      drawMessage(">> INICIAR EXAME <<");
    }
  }
}

void handleBtnFood(){ 
  if(digitalRead(btnFood) == HIGH)
  {
    timerInit = millis();

    while((millis() - timerInit < TIMER_LONG) && digitalRead(btnFood) == HIGH){delay(1);};

    if(millis() - timerInit >= TIMER_LONG && getExameOn())
    {
      sendCommand(CMD_FOOD, 1);

      drawMessage(">> ALIMENTAÇAO <<");
    } 

    if(millis() - timerInit < TIMER_LITLE)
    {
      sendCommand(CMD_CALIBRATE_PH1, 1);

      drawMessage(">> CALIBRATE PH1 <<");
    }
  }
}

void drawMessage(String message){
    display.clearDisplay();
    display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    display.setCursor(2,2);
    display.setTextSize(1);             // Draw 2X-scale text
    display.println(message);
    Serial.println("messages");
    display.display();
    delay(2000);
}
